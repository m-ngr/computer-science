;; Mahmoud Elnagar 23/06/2022
#lang racket
(require "hw5.rkt")
(require rackunit)
(require rackunit/text-ui)

(run-tests
 (test-suite
  "Problem 1-A: racketlist->mupllist"
  (check-equal? (racketlist->mupllist null) (aunit) "empty list")
  
  (check-equal? (racketlist->mupllist (list (int 3)))
                (apair (int 3) (aunit)) "1-element list")
  
  (check-equal? (racketlist->mupllist (list (int 3) (int 4)))
                (apair (int 3) (apair (int 4) (aunit))) "longer lists")
  ))

(run-tests
 (test-suite
  "Problem 1-B: mupllist->racketlist"
  (check-equal? (mupllist->racketlist (aunit)) null "empty list")
  (check-equal? (mupllist->racketlist (apair (int 3) (aunit)))
                (list (int 3)) "1-element list")
  (check-equal? (mupllist->racketlist (apair (int 3) (apair (int 4) (aunit))))
                (list (int 3) (int 4)) "longer lists")
  ))

(run-tests
 (test-suite
  "Problem 2: eval-exp"
  ;; Variable: (var String)
  (check-exn exn:fail? (lambda() (eval-under-env (var "x") null))
             "variable doesn't exist in env")
  (check-equal? (eval-under-env (var "x") (list (cons "x" (int 17))))
                (int 17) "variable exists in env")
  ;; Integer: (int Number)
  (check-equal? (eval-exp (int 2)) (int 2) "int eval to itself")
  ;; Add: (add MUPL MUPL)
  (check-exn exn:fail? (lambda() (eval-exp (add (aunit) (int 2))))
             "e1 is not an int")
  (check-exn exn:fail? (lambda() (eval-exp (add (int 2) (aunit))))
             "e2 is not an int")
  
  (check-equal? (eval-exp (add (int 1) (int 2))) (int 3) "add two ints")
  
  (check-equal? (eval-under-env (add (var "x") (var "y"))
                                (list (cons "x" (int 4)) (cons "y" (int 5))))
                (int 9) "e1 MUPL eval to int + e2 MUPL eval to int")
  ;; Conditional: (ifgreater MUPL MUPL MUPL MUPL)
  (check-exn exn:fail? (lambda() (eval-exp(ifgreater (aunit) (int 4) (int 3) (int 2))))
             "e1 is doesn't eval to int")
  (check-exn exn:fail? (lambda() (eval-exp(ifgreater (int 4) (aunit) (int 3) (int 2))))
             "e2 is doesn't eval to int")
  (check-equal? (eval-exp (ifgreater (int 5) (int 4) (add (int 1)(int 2)) (aunit)))
                (int 3) "e1 > e2 : eval e3")
  (check-equal? (eval-exp (ifgreater (int 4) (int 4) (aunit) (add (int 2)(int 2))))
                (int 4) "e1 = e2 : eval e4")
  (check-equal? (eval-exp (ifgreater (int 3) (int 4) (int 2) (aunit)))
                (aunit) "e1 < e2 : eval e4")
  ;; Function Definition: (fun String|#f String MUPL)
  (check-equal? (eval-under-env (fun #f "x" (add (var "x") (int 1))) null)
                (closure null (fun #f "x" (add (var "x") (int 1))))
                "anonymous fun eval to closure")
  (check-equal? (eval-under-env (fun "f1" "x" (add (var "x") (var "y"))) (list (cons "y" (int 7))))
                (closure (list (cons "y" (int 7))) (fun "f1" "x" (add (var "x") (var "y"))))
                "regular fun eval to closure")
  ;; Function Call: (call MUPL MUPL)
  (check-exn exn:fail? (lambda() (eval-exp (call (int 7) (int 5))))
             "e1 is not a closure")
  (check-equal? (eval-exp (call (closure null (fun #f "x" (add (var "x") (int 1))))
                                (int 2)))
                (int 3) "uses function argument")
  (check-equal? (eval-under-env
                 (call (closure (list (cons "y" (int 7))) (fun "f1" "x" (add (var "x") (var "y"))))
                       (int 2)) (list (cons "y" (int 100))))
                (int 9) "fun-body uses closure env not current env")
  (check-equal? (eval-under-env
                 (call (closure (list (cons "y" (int 7))) (fun "f1" "x" (add (var "x") (var "y"))))
                       (var "y")) (list (cons "y" (int 100))))
                (int 107) "fun-body uses closure env, fun-formal uses current env")
  ;; Let Expression: (mlet String MUPL MUPL)
  (check-equal? (eval-exp (mlet "x" (add (int 5) (int 2)) (var "x")))
                (int 7) "mlet test 1")
  (check-equal? (eval-exp (mlet "x" (int 1) (add (int 5) (var "x"))))
                (int 6) "mlet test 2")
  ;; Pairs: (apair MUPL MUPL)
  (check-equal? (eval-exp (apair (int 7) (aunit)))
                (apair (int 7) (aunit)) "a pair of values")
  (check-equal? (eval-exp (apair (add (int 1) (int 2)) (add (int 2) (int 2))))
                (apair (int 3) (int 4)) "a pair of MUPLs")
  ;; First: (fst MUPL)
  (check-exn exn:fail? (lambda() (eval-exp (fst (int 7)))) "e is not a pair")
  (check-equal? (eval-exp (fst (apair (int 1) (int 2)))) (int 1) "e is a pair")
  (check-equal? (eval-exp (fst (apair (add (int 1) (int 2))(aunit)))) (int 3) "e is a list")
  ;; Second: (snd MUPL)
  (check-exn exn:fail? (lambda() (eval-exp (snd (int 7)))) "e is not a pair")
  (check-equal? (eval-exp (snd (apair (int 1) (int 2)))) (int 2) "e is a pair")
  (check-equal? (eval-exp (snd (apair (add (int 1) (int 2))(aunit)))) (aunit) "e is a list")
  ;; Unit: (aunit)
  (check-equal? (eval-exp (aunit)) (aunit) "aunit is a value")
  ;; is Unit: (isaunit MUPL)
  (check-equal? (eval-exp (isaunit (int 4))) (int 0) "not a unit")
  (check-equal? (eval-exp (isaunit (aunit))) (int 1) "is a unit")
  (check-equal? (eval-exp (isaunit (closure '() (fun #f "x" (aunit)))))
                (int 0) "not a unit")
  (check-equal? (eval-exp (isaunit (call (closure '() (fun #f "x" (aunit))) (int 0))))
                (int 1) "is a unit")
  ;; Closure: (closure ENV FUN)
  (check-equal? (eval-exp (closure null (fun #f "x" (int 2))))
                (closure null (fun #f "x" (int 2))) "Closure eval to itself")
  ))

(run-tests
 (test-suite
  "Problem 3-A: ifaunit"
  (check-equal? (eval-exp (ifaunit (int 1) (int 2) (int 3))) (int 3) "e1 not aunit")
  (check-equal? (eval-exp (ifaunit (aunit) (int 2) (int 3))) (int 2) "e1 is  aunit")
  ))

(run-tests
 (test-suite
  "Problem 3-B: mlet*"
  (check-equal? (eval-exp (mlet* null (int 10))) (int 10) "no bindings")
  (check-equal? (eval-exp (mlet* (list (cons "x" (int 10))) (var "x")))
                (int 10) "one binding")
  (check-equal? (eval-exp (mlet* (list (cons "x" (int 15)) (cons "y" (var "x")))
                                 (add (var "x") (var "y"))))
                (int 30) "two bindings")
  (check-equal? (eval-under-env (mlet* null (var "x")) (list (cons "x" (int 5))))
                (int 5) "no bindings with env")
  (check-equal? (eval-under-env (mlet* (list (cons "x" (int 10))) (var "x"))
                                (list (cons "x" (int 5))))
                (int 10) "local binding shadowing env")
  (check-equal? (eval-under-env (mlet* (list (cons "y" (int 10)))
                                       (add (var "x") (var "y")))
                                (list (cons "x" (int 5))))
                (int 15) "local binding doesn't shadow env")
  (check-equal? (eval-under-env (mlet* (list (cons "x" (add (int 2)(var "x")))) (var "x"))
                                (list (cons "x" (int 5))))
                (int 7) "local binding use env then shadow it")
  ))

(run-tests
 (test-suite
  "Problem 3-C: ifeq"
  (check-equal? (eval-exp (ifeq (int 1) (int 2) (int 3) (int 4))) (int 4) "e1 < e2")
  (check-equal? (eval-exp (ifeq (int 2) (int 2) (int 3) (int 4))) (int 3) "e1 = e2")
  (check-equal? (eval-exp (ifeq (int 3) (int 2) (int 3) (int 4))) (int 4) "e1 > e2")
  ))

(run-tests
 (test-suite
  "Problem 4-A: mupl-map"
  (check-equal? (eval-exp (call (call mupl-map (fun #f "x" (add (var "x") (int 7))))
                                (aunit))) 
                (aunit) "empty list")
  (check-equal? (eval-exp (call (call mupl-map (fun #f "x" (add (var "x") (int 7))))
                                (apair (int 1) (aunit)))) 
                (apair (int 8) (aunit)) "1-element list")
  (check-equal? (eval-exp (call (call mupl-map (fun #f "x" (add (var "x") (int 7))))
                                (apair (int 1) (apair (int 2) (aunit))))) 
                (apair (int 8) (apair (int 9) (aunit))) "2-element list")
  ))

(run-tests
 (test-suite
  "Problem 4-B: mupl-map"
  (check-equal? (eval-exp (call (call mupl-mapAddN (int 2))(aunit)))
                (aunit) "empty list")
  (check-equal? (eval-exp (call (call mupl-mapAddN (int 2))(apair (int 2)(aunit))))
                (apair (int 4)(aunit)) "1-element list")
  (check-equal? (eval-exp (call (call mupl-mapAddN (int 3))
                                (apair (int 1) (apair (int 2) (aunit)))))
                (apair (int 4) (apair (int 5) (aunit))) "2-element list")
  
  (check-equal? (mupllist->racketlist
                 (eval-exp (call (call mupl-mapAddN (int 7))
                                 (racketlist->mupllist 
                                  (list (int 3) (int 4) (int 9))))))
                (list (int 10) (int 11) (int 16)) "combined test")
  ))

(run-tests
 (test-suite
  "Problem 5-A: get-free-vars"
  (check-equal? (get-free-vars (var "x")) (set "x") "var exp")
  (check-equal? (get-free-vars (int 7)) (set) "int exp")
  ;; Add Tests:
  (check-equal? (get-free-vars (add (int 7) (int 5)))
                (set) "add: e1 and e2 don't have free-vars")
  (check-equal? (get-free-vars (add (int 7) (var "y")))
                (set "y") "add: e1 doesn't have free-vars")
  (check-equal? (get-free-vars (add (var "x") (int 4)))
                (set "x") "add: e2 doesn't have vars")
  (check-equal? (get-free-vars (add (var "x") (var "x")))
                (set "x") "add: e1 and e2 have same free-vars")
  (check-equal? (get-free-vars (add (var "x") (var "y")))
                (set "x" "y") "add: e1 and e2 have different free-vars")
  ;; Conditional Tests:
  (check-equal? (get-free-vars (ifgreater (int 1) (int 2) (int 3) (int 4)))
                (set) "ifgreater: (e1,e2,e3,e4) don't have free-vars")
  
  (check-equal? (get-free-vars (ifgreater (var "x") (int 2) (int 3) (int 4)))
                (set "x") "ifgreater: (e2,e3,e4) don't have free-vars")
  (check-equal? (get-free-vars (ifgreater (int 1) (var "x") (int 3) (int 4)))
                (set "x") "ifgreater: (e1,e3,e4) don't have free-vars")
  (check-equal? (get-free-vars (ifgreater (int 1) (int 2) (var "x") (int 4)))
                (set "x") "ifgreater: (e1,e2,e4) don't have free-vars")
  (check-equal? (get-free-vars (ifgreater (int 1) (int 2) (int 3) (var "x")))
                (set "x") "ifgreater: (e1,e2,e3) don't have free-vars")

  (check-equal? (get-free-vars (ifgreater (var "x")(var "x")(var "x")(var "x")))
                (set "x") "ifgreater: (e1,e2,e3,e4) have same free-vars")
  (check-equal? (get-free-vars (ifgreater (var "w")(var "x")(var "y")(var "z")))
                (set "w" "x" "y" "z") "ifgreater: (e1,e2,e3,e4) have different free-vars")
  ;; Function Definition:
  (check-equal? (get-free-vars (fun "f" "x" (int 0)))
                (set) "fun: body has no free-vars")
  (check-equal? (get-free-vars (fun "f" "x" (var "x")))
                (set) "fun: body has fun-formal as var")
  (check-equal? (get-free-vars (fun "f" "x" (var "f")))
                (set) "fun: body has fun-optname as var")
  (check-equal? (get-free-vars (fun #f "x" (var "f")))
                (set "f") "fun: body has free-vars | Anonymous Function")
  (check-equal? (get-free-vars (fun "f" "x" (var "y")))
                (set "y") "fun: body has free-vars | Regular Function")
  ;; Function Call:
  (check-equal? (get-free-vars (call (fun "f" "x" (int 0)) (int 7)))
                (set) "call: funexp and actual don't have free-vars")
  (check-equal? (get-free-vars (call (fun "f" "x" (int 0)) (var "x")))
                (set "x") "call: funexp doesn't have free-vars")
  (check-equal? (get-free-vars (call (var "f") (int 0)))
                (set "f") "call: actual doesn't have free-vars")
  (check-equal? (get-free-vars (call (var "f") (var "x")))
                (set "f" "x") "call: funexp and actual have free-vars")
  ;; Let-expression:
  (check-equal? (get-free-vars (mlet "x" (int 0) (int 1)))
                (set) "mlet: mlet-e and body have no free-vars")
  (check-equal? (get-free-vars (mlet "x" (int 0) (var "x")))
                (set) "mlet: body uses the mlet-var")
  (check-equal? (get-free-vars (mlet "x" (int 0) (var "y")))
                (set "y") "mlet: body has free-vars")
  (check-equal? (get-free-vars (mlet "x" (var "y") (int 1)))
                (set "y") "mlet: mlet-e has free-vars")
  (check-equal? (get-free-vars (mlet "x" (var "x") (int 1)))
                (set "x") "mlet: mlet-e has free-vars")
  (check-equal? (get-free-vars (mlet "x" (var "y") (var "x")))
                (set "y") "mlet: body uses local var")
  (check-equal? (get-free-vars (mlet "x" (var "x") (var "y")))
                (set "x" "y") "mlet: mlet-e and body have free-vars")
  ;; Pair:
  (check-equal? (get-free-vars (apair (int 1) (int 2)))
                (set) "apair: e1 and e2 don't have free-vars")
  (check-equal? (get-free-vars (apair (int 1) (var "y")))
                (set "y") "apair: e1 doesn't have free-vars")
  (check-equal? (get-free-vars (apair (var "x") (int 2)))
                (set "x") "apair: e2 doesn't have free-vars")
  (check-equal? (get-free-vars (apair (var "x") (var "x")))
                (set "x") "apair: e1 and e2 have same free-vars")
  (check-equal? (get-free-vars (apair (var "x") (var "y")))
                (set "x" "y") "apair: e1 and e2 have different free-vars")
  ;; First:
  (check-equal? (get-free-vars (fst (apair (int 0) (int 0))))
                (set) "fst: e doesn't have free-vars")
  (check-equal? (get-free-vars (fst (var "x")))
                (set "x") "fst: e have free-vars")
  ;; Second:
  (check-equal? (get-free-vars (snd (apair (int 0) (int 0))))
                (set) "snd: e doesn't have free-vars")
  (check-equal? (get-free-vars (snd (var "x")))
                (set "x") "snd: e have free-vars")
  ;; Unit:
  (check-equal? (get-free-vars (aunit))(set) "aunit has no free-vars")
  (check-equal? (get-free-vars (isaunit (int 7)))
                (set) "isaunit: e doesn't have free-vars")
  (check-equal? (get-free-vars (isaunit (var "x")))
                (set "x") "isaunit: e have free-vars")
  ))

(define test-fun (call (fun #f "x" (var "y"))(int 1)))
(define test-func (call (fun-challenge #f "x" (var "y") (set "y"))(int 1)))

(run-tests
 (test-suite
  "Problem 5-B: compute-free-vars"
  (check-equal? (compute-free-vars (var "x"))(var "x") "no change to var")
  (check-equal? (compute-free-vars (int 7))(int 7) "no change to int")
  ;; Add:
  (check-equal? (compute-free-vars (add (int 7) (int 8)))
                (add (int 7) (int 8)) "e1 & e2 don't have fun exp")
  (check-equal? (compute-free-vars (add (int 7) test-fun))
                (add (int 7) test-func) "e2 has a fun exp")
  (check-equal? (compute-free-vars (add test-fun (int 7)))
                (add test-func (int 7)) "e1 has a fun exp")
  (check-equal? (compute-free-vars (add test-fun test-fun))
                (add test-func test-func) "e1&e2 have fun exp")
  ;; Conditional:
  (check-equal? (compute-free-vars (ifgreater (int 1) (int 2) (int 3) (int 4)))
                (ifgreater (int 1) (int 2) (int 3) (int 4))
                "e1&e2&e3&e4 don't have fun exp")
  (check-equal? (compute-free-vars (ifgreater test-fun (int 2) (int 3) (int 4)))
                (ifgreater test-func (int 2) (int 3) (int 4))
                "e2&e3&e4 don't have fun exp")
  (check-equal? (compute-free-vars (ifgreater (int 1) test-fun (int 3) (int 4)))
                (ifgreater (int 1) test-func (int 3) (int 4))
                "e1&e3&e4 don't have fun exp")
  (check-equal? (compute-free-vars (ifgreater (int 1) (int 2) test-fun (int 4)))
                (ifgreater (int 1) (int 2) test-func (int 4))
                "e1&e2&e4 don't have fun exp")
  (check-equal? (compute-free-vars (ifgreater (int 1) (int 2) (int 3) test-fun))
                (ifgreater (int 1) (int 2) (int 3) test-func)
                "e1&e2&e3 don't have fun exp")
  (check-equal? (compute-free-vars (ifgreater test-fun test-fun test-fun test-fun))
                (ifgreater test-func test-func test-func test-func)
                "e1&e2&e3&e4 have fun exp")
  ;; Function Definition:
  (check-equal? (compute-free-vars (fun "f" "x" (int 0)))
                (fun-challenge "f" "x" (int 0) (set)) "no free-vars")
  (check-equal? (compute-free-vars (fun "f" "x" (var "x")))
                (fun-challenge "f" "x" (var "x") (set)) "var is fun-formal")
  (check-equal? (compute-free-vars (fun "f" "x" (var "f")))
                (fun-challenge "f" "x" (var "f") (set)) "var is fun-optname")
  (check-equal? (compute-free-vars (fun #f "x" (var "f")))
                (fun-challenge #f "x" (var "f") (set "f")) "body has free-vars | Anonymous Function")
  (check-equal? (compute-free-vars (fun "f" "x" (var "y")))
                (fun-challenge "f" "x" (var "y") (set "y")) "body has free-vars | Regular Function")

  (check-equal? (compute-free-vars
                 (fun "f1" "x"
                      (fun "f2" "y"
                           (mlet "z" (add (var "x")(add (var "y")(var "z")))
                                 (ifgreater (var "w") (var "z")
                                            (call (var "f2") (var "z"))
                                            (var "z"))))))
                
                (fun-challenge "f1" "x"
                               (fun-challenge "f2" "y"
                                              (mlet "z" (add (var "x")(add (var "y")(var "z")))
                                                    (ifgreater (var "w") (var "z")
                                                               (call (var "f2") (var "z"))
                                                               (var "z")))
                                              (set "x" "z" "w"))
                               (set "z" "w"))
                "Complex Test")
  ;; Function Call:
  (check-equal? (compute-free-vars (call (var "f") (var "x")))
                (call (var "f") (var "x")) "funexp & actual don't have fun exp")
  (check-equal? (compute-free-vars (call test-fun (var "x")))
                (call test-func (var "x")) "funexp has fun exp")
  (check-equal? (compute-free-vars (call (var "f") test-fun))
                (call (var "f") test-func) "actual has fun exp")
  (check-equal? (compute-free-vars (call test-fun test-fun))
                (call test-func test-func) "funexp & actual have fun exp")
  ;; Let-expression:
  (check-equal? (compute-free-vars (mlet "x" (int 1) (int 2)))
                (mlet "x" (int 1) (int 2)) "mlet-e & body don't have fun")
  (check-equal? (compute-free-vars (mlet "x" test-fun (int 2)))
                (mlet "x" test-func (int 2)) "mlet-e has fun")
  (check-equal? (compute-free-vars (mlet "x" (int 1) test-fun))
                (mlet "x" (int 1) test-func) "body has fun")
  (check-equal? (compute-free-vars (mlet "x" test-fun test-fun))
                (mlet "x" test-func test-func) "mlet-e & body have fun")
  ;; Pair:
  (check-equal? (compute-free-vars (apair (int 1) (int 2)))
                (apair (int 1) (int 2)) "e1 & e2 don't have fun")
  (check-equal? (compute-free-vars (apair test-fun (int 2)))
                (apair test-func (int 2)) "e1 has fun")
  (check-equal? (compute-free-vars (apair (int 1) test-fun))
                (apair (int 1) test-func) "e2 has fun")
  (check-equal? (compute-free-vars (apair test-fun test-fun))
                (apair test-func test-func) "e1 & e2 have fun")
  ;; First: 
  (check-equal? (compute-free-vars (fst (var "x")))
                (fst (var "x")) "fst-e doesn't have fun")
  (check-equal? (compute-free-vars (fst test-fun))
                (fst test-func) "fst-e has fun")
  ;; Second: 
  (check-equal? (compute-free-vars (snd (var "x")))
                (snd (var "x")) "snd-e doesn't have fun")
  (check-equal? (compute-free-vars (snd test-fun))
                (snd test-func) "snd-e has fun")
  ;; Unit:
  (check-equal? (compute-free-vars (aunit)) (aunit) "no change in aunit")
  (check-equal? (compute-free-vars (isaunit (var "x")))
                (isaunit (var "x")) "isaunit-e doesn't have fun")
  (check-equal? (compute-free-vars (isaunit test-fun))
                (isaunit test-func) "isaunit-e has fun")
  ))

(run-tests
 (test-suite
  "Problem 5-C: eval-exp-c"
  ;; Variable: (var String)
  (check-exn exn:fail? (lambda() (eval-under-env-c (var "x") null))
             "variable doesn't exist in env")
  (check-equal? (eval-under-env-c (var "x") (list (cons "x" (int 17))))
                (int 17) "variable exists in env")
  ;; Integer: (int Number)
  (check-equal? (eval-exp-c (int 2)) (int 2) "int eval to itself")
  ;; Add: (add MUPL MUPL)
  (check-exn exn:fail? (lambda() (eval-exp-c (add (aunit) (int 2))))
             "e1 is not an int")
  (check-exn exn:fail? (lambda() (eval-exp-c (add (int 2) (aunit))))
             "e2 is not an int")
  (check-equal? (eval-exp-c (add (int 1) (int 2))) (int 3) "add two ints")
  (check-equal? (eval-under-env-c (add (var "x") (var "y"))
                                  (list (cons "x" (int 4)) (cons "y" (int 5))))
                (int 9) "e1 MUPL eval to int + e2 MUPL eval to int")
  ;; Conditional: (ifgreater MUPL MUPL MUPL MUPL)
  (check-exn exn:fail? (lambda() (eval-exp-c(ifgreater (aunit) (int 4) (int 3) (int 2))))
             "e1 is doesn't eval to int")
  (check-exn exn:fail? (lambda() (eval-exp-c(ifgreater (int 4) (aunit) (int 3) (int 2))))
             "e2 is doesn't eval to int")
  (check-equal? (eval-exp-c (ifgreater (int 5) (int 4) (add (int 1)(int 2)) (aunit)))
                (int 3) "e1 > e2 : eval e3")
  (check-equal? (eval-exp-c (ifgreater (int 4) (int 4) (aunit) (add (int 2)(int 2))))
                (int 4) "e1 = e2 : eval e4")
  (check-equal? (eval-exp-c (ifgreater (int 3) (int 4) (int 2) (aunit)))
                (aunit) "e1 < e2 : eval e4")
  ;; Function Definition: (fun String|#f String MUPL)
  (check-equal? (eval-under-env-c (fun-challenge #f "x" (var "x") (set)) null)
                (closure null (fun #f "x" (var "x")))
                "anonymous fun eval to closure")
  (check-equal? (eval-under-env-c (fun-challenge "f" "x" (var "x") (set)) null)
                (closure null (fun "f" "x" (var "x")))
                "regular fun eval to closure")
  (check-equal? (eval-under-env-c (fun-challenge "f" "x" (var "x") (set))
                                  (list (cons "x" (int 7))))
                (closure null (fun "f" "x" (var "x")))
                "empty closure env")
  (check-equal? (eval-under-env-c (fun-challenge "f" "x" (var "y") (set "y"))
                                  (list (cons "x" (int 1)) (cons "y" (int 7))))
                (closure (list (cons "y" (int 7))) (fun "f" "x" (var "y")))
                "1-element closure env")
  (check-equal? (eval-under-env-c (fun-challenge "f" "x" (add (var "y") (var "z"))
                                                 (set "y" "z"))
                                  (list (cons "x" (int 1)) (cons "y" (int 7)) (cons "z" (int 2))))
                (closure (list (cons "y" (int 7)) (cons "z" (int 2)))
                         (fun "f" "x" (add (var "y") (var "z"))))
                "2-element closure env")
  
  ;; Function Call: (call MUPL MUPL)
  (check-exn exn:fail? (lambda() (eval-exp-c (call (int 7) (int 5))))
             "e1 is not a closure")
  (check-equal? (eval-exp-c (call (closure null (fun #f "x" (add (var "x") (int 1))))
                                  (int 2)))
                (int 3) "uses function argument")
  (check-equal? (eval-under-env-c
                 (call (closure (list (cons "y" (int 7))) (fun "f1" "x" (add (var "x") (var "y"))))
                       (int 2)) (list (cons "y" (int 100))))
                (int 9) "fun-body uses closure env not current env")
  (check-equal? (eval-under-env-c
                 (call (closure (list (cons "y" (int 7))) (fun "f1" "x" (add (var "x") (var "y"))))
                       (var "y")) (list (cons "y" (int 100))))
                (int 107) "fun-body uses closure env, fun-formal uses current env")
  ;; Let Expression: (mlet String MUPL MUPL)
  (check-equal? (eval-exp-c (mlet "x" (add (int 5) (int 2)) (var "x")))
                (int 7) "mlet test 1")
  (check-equal? (eval-exp-c (mlet "x" (int 1) (add (int 5) (var "x"))))
                (int 6) "mlet test 2")
  ;; Pairs: (apair MUPL MUPL)
  (check-equal? (eval-exp-c (apair (int 7) (aunit)))
                (apair (int 7) (aunit)) "a pair of values")
  (check-equal? (eval-exp-c (apair (add (int 1) (int 2)) (add (int 2) (int 2))))
                (apair (int 3) (int 4)) "a pair of MUPLs")
  ;; First: (fst MUPL)
  (check-exn exn:fail? (lambda() (eval-exp-c (fst (int 7)))) "e is not a pair")
  (check-equal? (eval-exp-c (fst (apair (int 1) (int 2)))) (int 1) "e is a pair")
  (check-equal? (eval-exp-c (fst (apair (add (int 1) (int 2))(aunit)))) (int 3) "e is a list")
  ;; Second: (snd MUPL)
  (check-exn exn:fail? (lambda() (eval-exp-c (snd (int 7)))) "e is not a pair")
  (check-equal? (eval-exp-c (snd (apair (int 1) (int 2)))) (int 2) "e is a pair")
  (check-equal? (eval-exp-c (snd (apair (add (int 1) (int 2))(aunit)))) (aunit) "e is a list")
  ;; Unit: (aunit)
  (check-equal? (eval-exp-c (aunit)) (aunit) "aunit is a value")
  ;; is Unit: (isaunit MUPL)
  (check-equal? (eval-exp-c (isaunit (int 4))) (int 0) "not a unit")
  (check-equal? (eval-exp-c (isaunit (aunit))) (int 1) "is a unit")
  (check-equal? (eval-exp-c (isaunit (closure '() (fun #f "x" (aunit)))))
                (int 0) "not a unit")
  (check-equal? (eval-exp-c (isaunit (call (closure '() (fun #f "x" (aunit))) (int 0))))
                (int 1) "is a unit")
  ;; Closure: (closure Env MUPL-fun)
  (check-equal? (eval-exp-c (closure null (fun #f "x" (int 2))))
                (closure null (fun #f "x" (int 2))) "Closure eval to itself")
  ))